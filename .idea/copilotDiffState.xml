<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;main.py&#10;SSH automation to check if a MSISDN exists on given servers by running interactive commands.&#10;All output from each command is written into per-server logs for traceability.&#10;&quot;&quot;&quot;&#10;&#10;import paramiko&#10;import time&#10;import logging&#10;import argparse&#10;import sys&#10;import os&#10;import socket&#10;import re&#10;from datetime import datetime&#10;&#10;# ---- ANSI Color Codes ----&#10;class Colors:&#10;    RESET = '\033[0m'&#10;    BOLD = '\033[1m'&#10;&#10;    # Foreground colors&#10;    BLACK = '\033[30m'&#10;    RED = '\033[31m'&#10;    GREEN = '\033[32m'&#10;    YELLOW = '\033[33m'&#10;    BLUE = '\033[34m'&#10;    MAGENTA = '\033[35m'&#10;    CYAN = '\033[36m'&#10;    WHITE = '\033[37m'&#10;&#10;    # Bright foreground colors&#10;    BRIGHT_BLACK = '\033[90m'&#10;    BRIGHT_RED = '\033[91m'&#10;    BRIGHT_GREEN = '\033[92m'&#10;    BRIGHT_YELLOW = '\033[93m'&#10;    BRIGHT_BLUE = '\033[94m'&#10;    BRIGHT_MAGENTA = '\033[95m'&#10;    BRIGHT_CYAN = '\033[96m'&#10;    BRIGHT_WHITE = '\033[97m'&#10;&#10;def strip_ansi_codes(text):&#10;    &quot;&quot;&quot;Remove ANSI color codes from text.&quot;&quot;&quot;&#10;    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')&#10;    return ansi_escape.sub('', text)&#10;&#10;class ColoredFormatter(logging.Formatter):&#10;    &quot;&quot;&quot;Custom formatter that adds colors to log levels&quot;&quot;&quot;&#10;&#10;    LEVEL_COLORS = {&#10;        logging.DEBUG: Colors.BRIGHT_BLACK,&#10;        logging.INFO: Colors.BRIGHT_CYAN,&#10;        logging.WARNING: Colors.BRIGHT_YELLOW,&#10;        logging.ERROR: Colors.BRIGHT_RED,&#10;        logging.CRITICAL: Colors.RED + Colors.BOLD,&#10;    }&#10;&#10;    def format(self, record):&#10;        # Save the original format&#10;        original_format = self._style._fmt&#10;&#10;        # Add color to the level name&#10;        level_color = self.LEVEL_COLORS.get(record.levelno, Colors.RESET)&#10;&#10;        # Color the entire log message based on level&#10;        if record.levelno == logging.DEBUG:&#10;            self._style._fmt = f'{Colors.BRIGHT_BLACK}%(asctime)s{Colors.RESET} [{level_color}%(levelname)s{Colors.RESET}] {Colors.BRIGHT_BLACK}%(message)s{Colors.RESET}'&#10;        elif record.levelno == logging.INFO:&#10;            self._style._fmt = f'{Colors.BRIGHT_WHITE}%(asctime)s{Colors.RESET} [{level_color}%(levelname)s{Colors.RESET}] %(message)s'&#10;        elif record.levelno == logging.WARNING:&#10;            self._style._fmt = f'{Colors.BRIGHT_WHITE}%(asctime)s{Colors.RESET} [{level_color}%(levelname)s{Colors.RESET}] {Colors.YELLOW}%(message)s{Colors.RESET}'&#10;        elif record.levelno &gt;= logging.ERROR:&#10;            self._style._fmt = f'{Colors.BRIGHT_WHITE}%(asctime)s{Colors.RESET} [{level_color}%(levelname)s{Colors.RESET}] {Colors.RED}%(message)s{Colors.RESET}'&#10;&#10;        result = logging.Formatter.format(self, record)&#10;&#10;        # Restore the original format&#10;        self._style._fmt = original_format&#10;&#10;        return result&#10;&#10;class PlainFormatter(logging.Formatter):&#10;    &quot;&quot;&quot;Custom formatter that strips ANSI color codes from log messages&quot;&quot;&quot;&#10;&#10;    def format(self, record):&#10;        result = logging.Formatter.format(self, record)&#10;        return strip_ansi_codes(result)&#10;&#10;# ---- Configuration ----&#10;SERVERS = [&#10;    {&quot;name&quot;: &quot;MSSTB4&quot;, &quot;ip&quot;: &quot;172.29.108.42&quot;,  &quot;user&quot;: &quot;AUTOMA&quot;, &quot;password&quot;: &quot;AUTOMA-1&quot;},&#10;    {&quot;name&quot;: &quot;MSSTB5&quot;, &quot;ip&quot;: &quot;172.29.108.106&quot;, &quot;user&quot;: &quot;AUTOMA&quot;, &quot;password&quot;: &quot;AUTOMA-1&quot;},&#10;]&#10;&#10;READ_TIMEOUT = 6.0&#10;LOG_DIR = &quot;logs&quot;&#10;os.makedirs(LOG_DIR, exist_ok=True)&#10;&#10;# ---- Logging ----&#10;def build_logger(server_ip=None):&#10;    &quot;&quot;&quot;Create a composite logger (console + optional file).&quot;&quot;&quot;&#10;    logger = logging.getLogger(server_ip or &quot;msisdn-check&quot;)&#10;    logger.setLevel(logging.DEBUG)&#10;&#10;    # Clear existing handlers to avoid duplicates&#10;    logger.handlers.clear()&#10;&#10;    # Console handler with colors&#10;    ch = logging.StreamHandler(sys.stdout)&#10;    ch.setLevel(logging.INFO)&#10;    colored_formatter = ColoredFormatter(&quot;%(asctime)s %(levelname)s %(message)s&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)&#10;    ch.setFormatter(colored_formatter)&#10;    logger.addHandler(ch)&#10;&#10;    # File handler - mode='w' to overwrite instead of append (no colors in file)&#10;    if server_ip:&#10;        fh = logging.FileHandler(os.path.join(LOG_DIR, f&quot;{server_ip}.log&quot;), mode=&quot;w&quot;)&#10;        fh.setLevel(logging.DEBUG)&#10;        plain_formatter = PlainFormatter(&quot;%(asctime)s [%(levelname)s] %(message)s&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)&#10;        fh.setFormatter(plain_formatter)&#10;        logger.addHandler(fh)&#10;&#10;    return logger&#10;&#10;def process_backspaces(output):&#10;    &quot;&quot;&quot;Process backspace characters to simulate terminal behavior.&quot;&quot;&quot;&#10;    result = []&#10;    for char in output:&#10;        if char == '\b' or char == '\x08':  # Backspace character&#10;            if result:&#10;                result.pop()  # Remove last character&#10;        else:&#10;            result.append(char)&#10;    return ''.join(result)&#10;&#10;&#10;def stream_channel_output(chan, timeout=READ_TIMEOUT):&#10;    &quot;&quot;&quot;Continuously read shell output until timeout expires.&quot;&quot;&quot;&#10;    output = []&#10;    start = time.time()&#10;    while True:&#10;        if chan.recv_ready():&#10;            try:&#10;                data = chan.recv(4096).decode('utf-8', errors='ignore')&#10;            except socket.timeout:&#10;                break&#10;            if not data:&#10;                break&#10;            output.append(data)&#10;            start = time.time()&#10;        else:&#10;            time.sleep(0.1)&#10;        if time.time() - start &gt; timeout:&#10;            break&#10;    raw_output = &quot;&quot;.join(output)&#10;    return process_backspaces(raw_output)&#10;&#10;&#10;def connect_and_check(server, msisdn):&#10;    &quot;&quot;&quot;Connects via SSH, executes commands, returns (found, output_text).&quot;&quot;&quot;&#10;    logger = build_logger(server[&quot;ip&quot;])&#10;    logger.info(&quot;Connecting to %s (%s)...&quot;, server.get(&quot;name&quot;, &quot;&quot;), server[&quot;ip&quot;])&#10;&#10;    client = paramiko.SSHClient()&#10;    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())&#10;&#10;    try:&#10;        client.connect(&#10;            server[&quot;ip&quot;],&#10;            username=server[&quot;user&quot;],&#10;            password=server[&quot;password&quot;],&#10;            look_for_keys=False,&#10;            allow_agent=False,&#10;            timeout=10&#10;        )&#10;    except Exception as e:&#10;        logger.error(&quot;SSH connection failed: %s&quot;, e)&#10;        return False, str(e)&#10;&#10;    logger.info(&quot;Connected. Opening interactive shell...&quot;)&#10;    chan = client.invoke_shell()&#10;    chan.settimeout(2.0)&#10;    time.sleep(0.5)&#10;&#10;    banner = stream_channel_output(chan, timeout=1.0)&#10;    logger.debug(&quot;Initial prompt:\n%s&quot;, banner)&#10;&#10;&#10;    commands = [&#10;        &quot;ZMVO&quot;,&#10;        f&quot;MSISDN={msisdn}&quot;,&#10;        f&quot;;&quot;&#10;    ]&#10;&#10;    full_output = []&#10;    for cmd in commands:&#10;        logger.info(f&quot;{Colors.BRIGHT_MAGENTA}Executing command:{Colors.RESET} {Colors.BRIGHT_GREEN}{cmd}{Colors.RESET}&quot;)&#10;        chan.send((cmd + &quot;\r\n&quot;).encode('utf-8'))&#10;        out = stream_channel_output(chan, timeout=READ_TIMEOUT)&#10;        full_output.append(f&quot;\n&gt;&gt;&gt; {cmd}\n{out}\n{'-'*80}\n&quot;)&#10;        # Show output in real-time in the terminal with yellow color&#10;        logger.info(f&quot;{Colors.BRIGHT_YELLOW}Command output:{Colors.RESET}\n{Colors.YELLOW}%s{Colors.RESET}&quot;, out)&#10;        if &quot;UNKNOWN SUBSCRIBER&quot; in out.upper() or &quot;DX ERROR&quot; in out.upper():&#10;            logger.info(f&quot;{Colors.RED}Detected UNKNOWN SUBSCRIBER pattern — stopping command sequence.{Colors.RESET}&quot;)&#10;            break&#10;&#10;    chan.close()&#10;    client.close()&#10;&#10;    output_text = &quot;&quot;.join(full_output)&#10;&#10;    # --- Determine presence ---&#10;    upper_out = output_text.upper()&#10;    if &quot;UNKNOWN SUBSCRIBER&quot; in upper_out or &quot;COMMAND EXECUTION FAILED&quot; in upper_out:&#10;        found = False&#10;        logger.info(&quot;MSISDN %s NOT PRESENT on %s&quot;, msisdn, server[&quot;ip&quot;])&#10;    elif &quot;SUBSCRIBER INFORMATION&quot; in upper_out or &quot;MOBILE COUNTRY CODE&quot; in upper_out:&#10;        found = True&#10;        logger.info(&quot;MSISDN %s PRESENT on %s&quot;, msisdn, server[&quot;ip&quot;])&#10;    else:&#10;        found = False&#10;        logger.warning(&quot;Could not definitively determine presence; treating as NOT FOUND.&quot;)&#10;&#10;    return found, output_text&#10;&#10;&#10;def main(msisdn):&#10;    root_logger = build_logger()&#10;    root_logger.info(&quot;Starting MSISDN lookup for %s&quot;, msisdn)&#10;&#10;    # Clear summary file at start of new run&#10;    summary_file = os.path.join(LOG_DIR, &quot;summary.txt&quot;)&#10;    with open(summary_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as sf:&#10;        sf.write(f&quot;MSISDN Lookup Report - {datetime.now().isoformat()}\n&quot;)&#10;        sf.write(f&quot;Searching for: {msisdn}\n&quot;)&#10;        sf.write(&quot;=&quot;*60 + &quot;\n\n&quot;)&#10;&#10;    for server in SERVERS:&#10;        found, output = connect_and_check(server, msisdn)&#10;        with open(summary_file, &quot;a&quot;, encoding=&quot;utf-8&quot;) as sf:&#10;            sf.write(f&quot;{server['name']} ({server['ip']}) - Found={found}\n&quot;)&#10;        if found:&#10;            root_logger.info(&quot;✅ Found MSISDN on %s (%s). Stopping search.&quot;, server[&quot;name&quot;], server[&quot;ip&quot;])&#10;            return&#10;        else:&#10;            root_logger.info(&quot;MSISDN not found on %s (%s). Checking next server...&quot;, server[&quot;name&quot;], server[&quot;ip&quot;])&#10;&#10;    root_logger.info(&quot;❌ MSISDN not found on any configured servers.&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    parser = argparse.ArgumentParser(description=&quot;Check MSISDN presence via SSH automation.&quot;)&#10;    parser.add_argument(&quot;--msisdn&quot;, &quot;-m&quot;, required=True, help=&quot;MSISDN to check (e.g., 4915781993214)&quot;)&#10;    args = parser.parse_args()&#10;    main(args.msisdn)&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;main.py&#10;SSH automation to check if a MSISDN exists on given servers by running interactive commands.&#10;All output from each command is written into per-server logs for traceability.&#10;&quot;&quot;&quot;&#10;&#10;import paramiko&#10;import time&#10;import logging&#10;import argparse&#10;import sys&#10;import os&#10;import socket&#10;import re&#10;from datetime import datetime&#10;&#10;# ---- ANSI Color Codes ----&#10;class Colors:&#10;    RESET = '\033[0m'&#10;    BOLD = '\033[1m'&#10;&#10;    # Foreground colors&#10;    BLACK = '\033[30m'&#10;    RED = '\033[31m'&#10;    GREEN = '\033[32m'&#10;    YELLOW = '\033[33m'&#10;    BLUE = '\033[34m'&#10;    MAGENTA = '\033[35m'&#10;    CYAN = '\033[36m'&#10;    WHITE = '\033[37m'&#10;&#10;    # Bright foreground colors&#10;    BRIGHT_BLACK = '\033[90m'&#10;    BRIGHT_RED = '\033[91m'&#10;    BRIGHT_GREEN = '\033[92m'&#10;    BRIGHT_YELLOW = '\033[93m'&#10;    BRIGHT_BLUE = '\033[94m'&#10;    BRIGHT_MAGENTA = '\033[95m'&#10;    BRIGHT_CYAN = '\033[96m'&#10;    BRIGHT_WHITE = '\033[97m'&#10;&#10;def strip_ansi_codes(text):&#10;    &quot;&quot;&quot;Remove ANSI color codes from text.&quot;&quot;&quot;&#10;    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')&#10;    return ansi_escape.sub('', text)&#10;&#10;class ColoredFormatter(logging.Formatter):&#10;    &quot;&quot;&quot;Custom formatter that adds colors to log levels&quot;&quot;&quot;&#10;&#10;    LEVEL_COLORS = {&#10;        logging.DEBUG: Colors.BRIGHT_BLACK,&#10;        logging.INFO: Colors.BRIGHT_CYAN,&#10;        logging.WARNING: Colors.BRIGHT_YELLOW,&#10;        logging.ERROR: Colors.BRIGHT_RED,&#10;        logging.CRITICAL: Colors.RED + Colors.BOLD,&#10;    }&#10;&#10;    def format(self, record):&#10;        # Save the original format&#10;        original_format = self._style._fmt&#10;&#10;        # Add color to the level name&#10;        level_color = self.LEVEL_COLORS.get(record.levelno, Colors.RESET)&#10;&#10;        # Color the entire log message based on level&#10;        if record.levelno == logging.DEBUG:&#10;            self._style._fmt = f'{Colors.BRIGHT_BLACK}%(asctime)s{Colors.RESET} [{level_color}%(levelname)s{Colors.RESET}] {Colors.BRIGHT_BLACK}%(message)s{Colors.RESET}'&#10;        elif record.levelno == logging.INFO:&#10;            self._style._fmt = f'{Colors.BRIGHT_WHITE}%(asctime)s{Colors.RESET} [{level_color}%(levelname)s{Colors.RESET}] %(message)s'&#10;        elif record.levelno == logging.WARNING:&#10;            self._style._fmt = f'{Colors.BRIGHT_WHITE}%(asctime)s{Colors.RESET} [{level_color}%(levelname)s{Colors.RESET}] {Colors.YELLOW}%(message)s{Colors.RESET}'&#10;        elif record.levelno &gt;= logging.ERROR:&#10;            self._style._fmt = f'{Colors.BRIGHT_WHITE}%(asctime)s{Colors.RESET} [{level_color}%(levelname)s{Colors.RESET}] {Colors.RED}%(message)s{Colors.RESET}'&#10;&#10;        result = logging.Formatter.format(self, record)&#10;&#10;        # Restore the original format&#10;        self._style._fmt = original_format&#10;&#10;        return result&#10;&#10;class PlainFormatter(logging.Formatter):&#10;    &quot;&quot;&quot;Custom formatter that strips ANSI color codes from log messages&quot;&quot;&quot;&#10;&#10;    def format(self, record):&#10;        result = logging.Formatter.format(self, record)&#10;        return strip_ansi_codes(result)&#10;&#10;# ---- Configuration ----&#10;SERVERS = [&#10;    {&quot;name&quot;: &quot;MSSTB4&quot;, &quot;ip&quot;: &quot;172.29.108.42&quot;,  &quot;user&quot;: &quot;AUTOMA&quot;, &quot;password&quot;: &quot;AUTOMA-1&quot;},&#10;    {&quot;name&quot;: &quot;MSSTB5&quot;, &quot;ip&quot;: &quot;172.29.108.106&quot;, &quot;user&quot;: &quot;AUTOMA&quot;, &quot;password&quot;: &quot;AUTOMA-1&quot;},&#10;]&#10;&#10;READ_TIMEOUT = 6.0&#10;LOG_DIR = &quot;logs&quot;&#10;os.makedirs(LOG_DIR, exist_ok=True)&#10;&#10;# ---- Logging ----&#10;def build_logger(server_ip=None):&#10;    &quot;&quot;&quot;Create a composite logger (console + optional file).&quot;&quot;&quot;&#10;    logger = logging.getLogger(server_ip or &quot;msisdn-check&quot;)&#10;    logger.setLevel(logging.DEBUG)&#10;&#10;    # Clear existing handlers to avoid duplicates&#10;    logger.handlers.clear()&#10;&#10;    # Console handler with colors&#10;    ch = logging.StreamHandler(sys.stdout)&#10;    ch.setLevel(logging.INFO)&#10;    colored_formatter = ColoredFormatter(&quot;%(asctime)s %(levelname)s %(message)s&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)&#10;    ch.setFormatter(colored_formatter)&#10;    logger.addHandler(ch)&#10;&#10;    # File handler - mode='w' to overwrite instead of append (no colors in file)&#10;    if server_ip:&#10;        fh = logging.FileHandler(os.path.join(LOG_DIR, f&quot;{server_ip}.log&quot;), mode=&quot;w&quot;)&#10;        fh.setLevel(logging.DEBUG)&#10;        plain_formatter = PlainFormatter(&quot;%(asctime)s [%(levelname)s] %(message)s&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)&#10;        fh.setFormatter(plain_formatter)&#10;        logger.addHandler(fh)&#10;&#10;    return logger&#10;&#10;def process_backspaces(output):&#10;    &quot;&quot;&quot;Process backspace characters to simulate terminal behavior.&quot;&quot;&quot;&#10;    result = []&#10;    for char in output:&#10;        if char == '\b' or char == '\x08':  # Backspace character&#10;            if result:&#10;                result.pop()  # Remove last character&#10;        else:&#10;            result.append(char)&#10;    return ''.join(result)&#10;&#10;&#10;def stream_channel_output(chan, timeout=READ_TIMEOUT):&#10;    &quot;&quot;&quot;Continuously read shell output until timeout expires.&quot;&quot;&quot;&#10;    output = []&#10;    start = time.time()&#10;    while True:&#10;        if chan.recv_ready():&#10;            try:&#10;                data = chan.recv(4096).decode('utf-8', errors='ignore')&#10;            except socket.timeout:&#10;                break&#10;            if not data:&#10;                break&#10;            output.append(data)&#10;            start = time.time()&#10;        else:&#10;            time.sleep(0.1)&#10;        if time.time() - start &gt; timeout:&#10;            break&#10;    raw_output = &quot;&quot;.join(output)&#10;    return process_backspaces(raw_output)&#10;&#10;&#10;def connect_and_check(server, msisdn):&#10;    &quot;&quot;&quot;Connects via SSH, executes commands, returns (found, output_text).&quot;&quot;&quot;&#10;    logger = build_logger(server[&quot;ip&quot;])&#10;    logger.info(&quot;Connecting to %s (%s)...&quot;, server.get(&quot;name&quot;, &quot;&quot;), server[&quot;ip&quot;])&#10;&#10;    client = paramiko.SSHClient()&#10;    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())&#10;&#10;    try:&#10;        client.connect(&#10;            server[&quot;ip&quot;],&#10;            username=server[&quot;user&quot;],&#10;            password=server[&quot;password&quot;],&#10;            look_for_keys=False,&#10;            allow_agent=False,&#10;            timeout=10&#10;        )&#10;    except Exception as e:&#10;        logger.error(&quot;SSH connection failed: %s&quot;, e)&#10;        return False, str(e)&#10;&#10;    logger.info(&quot;Connected. Opening interactive shell...&quot;)&#10;    chan = client.invoke_shell()&#10;    chan.settimeout(2.0)&#10;    time.sleep(0.5)&#10;&#10;    banner = stream_channel_output(chan, timeout=1.0)&#10;    logger.debug(&quot;Initial prompt:\n%s&quot;, banner)&#10;&#10;&#10;    commands = [&#10;        &quot;ZMVO&quot;,&#10;        f&quot;MSISDN={msisdn}&quot;,&#10;        f&quot;;&quot;&#10;    ]&#10;&#10;    full_output = []&#10;    for cmd in commands:&#10;        logger.info(f&quot;{Colors.BRIGHT_MAGENTA}Executing command:{Colors.RESET} {Colors.BRIGHT_GREEN}{cmd}{Colors.RESET}&quot;)&#10;        chan.send((cmd + &quot;\r\n&quot;).encode('utf-8'))&#10;        out = stream_channel_output(chan, timeout=READ_TIMEOUT)&#10;        full_output.append(f&quot;\n&gt;&gt;&gt; {cmd}\n{out}\n{'-'*80}\n&quot;)&#10;        # Show output in real-time in the terminal with yellow color&#10;        logger.info(f&quot;{Colors.BRIGHT_YELLOW}Command output:{Colors.RESET}\n{Colors.YELLOW}%s{Colors.RESET}&quot;, out)&#10;        if &quot;UNKNOWN SUBSCRIBER&quot; in out.upper() or &quot;DX ERROR&quot; in out.upper():&#10;            logger.info(f&quot;{Colors.RED}Detected UNKNOWN SUBSCRIBER pattern — stopping command sequence.{Colors.RESET}&quot;)&#10;            break&#10;&#10;    chan.close()&#10;    client.close()&#10;&#10;    output_text = &quot;&quot;.join(full_output)&#10;&#10;    # --- Determine presence ---&#10;    upper_out = output_text.upper()&#10;    if &quot;UNKNOWN SUBSCRIBER&quot; in upper_out or &quot;COMMAND EXECUTION FAILED&quot; in upper_out:&#10;        found = False&#10;        logger.info(&quot;MSISDN %s NOT PRESENT on %s&quot;, msisdn, server[&quot;ip&quot;])&#10;    elif &quot;SUBSCRIBER INFORMATION&quot; in upper_out or &quot;MOBILE COUNTRY CODE&quot; in upper_out:&#10;        found = True&#10;        logger.info(&quot;MSISDN %s PRESENT on %s&quot;, msisdn, server[&quot;ip&quot;])&#10;    else:&#10;        found = False&#10;        logger.warning(&quot;Could not definitively determine presence; treating as NOT FOUND.&quot;)&#10;&#10;    return found, output_text&#10;&#10;&#10;def main(msisdn):&#10;    root_logger = build_logger()&#10;    root_logger.info(&quot;Starting MSISDN lookup for %s&quot;, msisdn)&#10;&#10;    # Clear summary file at start of new run&#10;    summary_file = os.path.join(LOG_DIR, &quot;summary.txt&quot;)&#10;    with open(summary_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as sf:&#10;        sf.write(f&quot;MSISDN Lookup Report - {datetime.now().isoformat()}\n&quot;)&#10;        sf.write(f&quot;Searching for: {msisdn}\n&quot;)&#10;        sf.write(&quot;=&quot;*60 + &quot;\n\n&quot;)&#10;&#10;    for server in SERVERS:&#10;        found, output = connect_and_check(server, msisdn)&#10;        with open(summary_file, &quot;a&quot;, encoding=&quot;utf-8&quot;) as sf:&#10;            sf.write(f&quot;{server['name']} ({server['ip']}) - Found={found}\n&quot;)&#10;        if found:&#10;            root_logger.info(&quot;✅ Found MSISDN on %s (%s). Stopping search.&quot;, server[&quot;name&quot;], server[&quot;ip&quot;])&#10;            return&#10;        else:&#10;            root_logger.info(&quot;MSISDN not found on %s (%s). Checking next server...&quot;, server[&quot;name&quot;], server[&quot;ip&quot;])&#10;&#10;    root_logger.info(&quot;❌ MSISDN not found on any configured servers.&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    parser = argparse.ArgumentParser(description=&quot;Check MSISDN presence via SSH automation.&quot;)&#10;    parser.add_argument(&quot;--msisdn&quot;, &quot;-m&quot;, required=True, help=&quot;MSISDN to check (e.g., 4915781993214)&quot;)&#10;    args = parser.parse_args()&#10;    main(args.msisdn)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>