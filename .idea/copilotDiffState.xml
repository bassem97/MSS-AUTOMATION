<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/phone_call_automation.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/phone_call_automation.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;phone_call_automation.py&#10;Automates phone calls between mobile devices using ADB commands through STF.&#10;&quot;&quot;&quot;&#10;&#10;import subprocess&#10;import time&#10;import sys&#10;from typing import Optional&#10;&#10;from logging_config import build_logger&#10;&#10;&#10;class PhoneCallAutomation:&#10;    &quot;&quot;&quot;Handles automated phone calls between mobile devices via ADB.&quot;&quot;&quot;&#10;&#10;    def __init__(self, logger=None):&#10;        self.phones = {&#10;            &quot;phone A&quot;: {&#10;                &quot;msisdn&quot;: &quot;4915900103141&quot;,&#10;                &quot;ip_port&quot;: &quot;172.29.42.44:7437&quot;&#10;            },&#10;            &quot;phone B&quot;: {&#10;                &quot;msisdn&quot;: &quot;4915781993213&quot;,&#10;                &quot;ip_port&quot;: &quot;172.29.42.44:7445&quot;&#10;            }&#10;        }&#10;        # Initialize logger&#10;        self.logger = logger or build_logger(&quot;phone_call_automation&quot;)&#10;&#10;    def clean_msisdn(self, msisdn: str) -&gt; str:&#10;        &quot;&quot;&quot;Remove spaces from MSISDN.&quot;&quot;&quot;&#10;        return msisdn.replace(&quot; &quot;, &quot;&quot;)&#10;&#10;    def connect_device(self, ip_port: str) -&gt; bool:&#10;        &quot;&quot;&quot;Connect to a device via ADB.&quot;&quot;&quot;&#10;        try:&#10;            self.logger.info(f&quot;Connecting to device at {ip_port}...&quot;)&#10;            result = subprocess.run(&#10;                [&quot;adb&quot;, &quot;connect&quot;, ip_port],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=10&#10;            )&#10;&#10;            if result.returncode == 0:&#10;                self.logger.info(f&quot;✓ Successfully connected to {ip_port}&quot;)&#10;                self.logger.debug(f&quot;Output: {result.stdout.strip()}&quot;)&#10;                return True&#10;            else:&#10;                self.logger.error(f&quot;✗ Failed to connect to {ip_port}&quot;)&#10;                self.logger.error(f&quot;Error: {result.stderr.strip()}&quot;)&#10;                return False&#10;&#10;        except subprocess.TimeoutExpired:&#10;            self.logger.error(f&quot;✗ Connection to {ip_port} timed out&quot;)&#10;            return False&#10;        except FileNotFoundError:&#10;            self.logger.error(&quot;✗ ADB command not found. Please ensure ADB is installed and in PATH.&quot;)&#10;            return False&#10;        except Exception as e:&#10;            self.logger.error(f&quot;✗ Error connecting to {ip_port}: {e}&quot;)&#10;            return False&#10;&#10;    def disconnect_device(self, ip_port: str):&#10;        &quot;&quot;&quot;Disconnect from a device via ADB.&quot;&quot;&quot;&#10;        try:&#10;            self.logger.info(f&quot;Disconnecting from {ip_port}...&quot;)&#10;            subprocess.run(&#10;                [&quot;adb&quot;, &quot;disconnect&quot;, ip_port],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=5&#10;            )&#10;        except Exception as e:&#10;            self.logger.warning(f&quot;Error disconnecting from {ip_port}: {e}&quot;)&#10;&#10;    def make_call(self, caller_ip_port: str, caller_msisdn: str, recipient_msisdn: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Make a phone call from caller device to recipient number.&#10;&#10;        Args:&#10;            caller_ip_port: IP:PORT of the calling device&#10;            caller_msisdn: MSISDN of the caller&#10;            recipient_msisdn: Phone number to call (with country code, no spaces)&#10;&#10;        Returns:&#10;            bool: True if call was initiated successfully&#10;        &quot;&quot;&quot;&#10;        try:&#10;            self.logger.info(f&quot;Initiating call from {caller_msisdn} to {recipient_msisdn}...&quot;)&#10;&#10;            # ADB command to make a call&#10;            # Using 'am start' to launch dialer with phone number&#10;            call_command = f&quot;am start -a android.intent.action.CALL -d tel:{recipient_msisdn}&quot;&#10;&#10;            result = subprocess.run(&#10;                [&quot;adb&quot;, &quot;-s&quot;, caller_ip_port, &quot;shell&quot;, call_command],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=10&#10;            )&#10;&#10;            if result.returncode == 0:&#10;                self.logger.info(f&quot;✓ Call initiated successfully!&quot;)&#10;                self.logger.debug(f&quot;Output: {result.stdout.strip()}&quot;)&#10;                return True&#10;            else:&#10;                self.logger.error(f&quot;✗ Failed to initiate call&quot;)&#10;                self.logger.error(f&quot;Error: {result.stderr.strip()}&quot;)&#10;                return False&#10;&#10;        except subprocess.TimeoutExpired:&#10;            self.logger.error(f&quot;✗ Call command timed out&quot;)&#10;            return False&#10;        except Exception as e:&#10;            self.logger.error(f&quot;✗ Error making call: {e}&quot;)&#10;            return False&#10;&#10;    def end_call(self, device_ip_port: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        End the current call on a device.&#10;&#10;        Args:&#10;            device_ip_port: IP:PORT of the device&#10;&#10;        Returns:&#10;            bool: True if call was ended successfully&#10;        &quot;&quot;&quot;&#10;        try:&#10;            self.logger.info(f&quot;Ending call on {device_ip_port}...&quot;)&#10;&#10;            # Send keyevent to end call (KEYCODE_ENDCALL = 6)&#10;            result = subprocess.run(&#10;                [&quot;adb&quot;, &quot;-s&quot;, device_ip_port, &quot;shell&quot;, &quot;input&quot;, &quot;keyevent&quot;, &quot;6&quot;],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=5&#10;            )&#10;&#10;            if result.returncode == 0:&#10;                self.logger.info(f&quot;✓ Call ended successfully&quot;)&#10;                return True&#10;            else:&#10;                self.logger.error(f&quot;✗ Failed to end call&quot;)&#10;                self.logger.error(f&quot;Error: {result.stderr.strip()}&quot;)&#10;                return False&#10;&#10;        except Exception as e:&#10;            self.logger.error(f&quot;✗ Error ending call: {e}&quot;)&#10;            return False&#10;&#10;    def check_adb_available(self) -&gt; bool:&#10;        &quot;&quot;&quot;Check if ADB is available in the system.&quot;&quot;&quot;&#10;        try:&#10;            result = subprocess.run(&#10;                [&quot;adb&quot;, &quot;version&quot;],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=5&#10;            )&#10;            if result.returncode == 0:&#10;                version = result.stdout.strip().split()[4] if len(result.stdout.strip().split()) &gt; 4 else &quot;unknown&quot;&#10;                self.logger.info(f&quot;✓ ADB is available (Version: {version})&quot;)&#10;                return True&#10;            return False&#10;        except FileNotFoundError:&#10;            self.logger.error(&quot;✗ ADB is not installed or not in PATH&quot;)&#10;            return False&#10;        except Exception as e:&#10;            self.logger.error(f&quot;✗ Error checking ADB: {e}&quot;)&#10;            return False&#10;&#10;    def restart_adb_server(self) -&gt; bool:&#10;        &quot;&quot;&quot;Restart the ADB server by killing and starting it again.&quot;&quot;&quot;&#10;        try:&#10;            self.logger.info(&quot;Killing ADB server...&quot;)&#10;            result_kill = subprocess.run(&#10;                [&quot;adb&quot;, &quot;kill-server&quot;],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=10&#10;            )&#10;&#10;            if result_kill.returncode == 0:&#10;                self.logger.info(&quot;✓ ADB server killed successfully&quot;)&#10;            else:&#10;                self.logger.warning(f&quot;Warning: {result_kill.stderr.strip()}&quot;)&#10;&#10;            time.sleep(1)&#10;&#10;            self.logger.info(&quot;Starting ADB server...&quot;)&#10;            result_start = subprocess.run(&#10;                [&quot;adb&quot;, &quot;start-server&quot;],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=10&#10;            )&#10;&#10;            if result_start.returncode == 0:&#10;                self.logger.info(&quot;✓ ADB server started successfully&quot;)&#10;                self.logger.info(&quot;Note: You may need to authorize the connection on your device(s)&quot;)&#10;                return True&#10;            else:&#10;                self.logger.error(f&quot;✗ Failed to start ADB server: {result_start.stderr.strip()}&quot;)&#10;                return False&#10;&#10;        except subprocess.TimeoutExpired:&#10;            self.logger.error(&quot;✗ ADB server restart timed out&quot;)&#10;            return False&#10;        except Exception as e:&#10;            self.logger.error(f&quot;✗ Error restarting ADB server: {e}&quot;)&#10;            return False&#10;&#10;    def list_devices(self):&#10;        &quot;&quot;&quot;List all connected ADB devices.&quot;&quot;&quot;&#10;        try:&#10;            result = subprocess.run(&#10;                [&quot;adb&quot;, &quot;devices&quot;],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=5&#10;            )&#10;            self.logger.info(&quot;=== Connected ADB Devices ===&quot;)&#10;            for line in result.stdout.strip().split('\n'):&#10;                self.logger.info(line)&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Error listing devices: {e}&quot;)&#10;&#10;    def make_phone_call(self, from_phone: str, to_phone: str, duration: Optional[int] = None):&#10;        &quot;&quot;&quot;&#10;        Make a phone call from one device to another.&#10;&#10;        Args:&#10;            from_phone: Caller phone ID ('phone1' or 'phone2')&#10;            to_phone: Recipient phone ID ('phone1' or 'phone2')&#10;            duration: Optional duration in seconds to keep the call active before ending&#10;&#10;        Returns:&#10;            bool: True if call was initiated successfully&#10;        &quot;&quot;&quot;&#10;        if from_phone not in self.phones or to_phone not in self.phones:&#10;            self.logger.error(f&quot;✗ Invalid phone ID. Use 'phone A' or 'phone B'&quot;)&#10;            return False&#10;&#10;        caller = self.phones[from_phone]&#10;        recipient = self.phones[to_phone]&#10;&#10;        self.logger.info(&quot;=&quot; * 60)&#10;        self.logger.info(f&quot;CALLING: {from_phone.upper()} → {to_phone.upper()}&quot;)&#10;        self.logger.info(f&quot;From: {caller['msisdn']} ({caller['ip_port']})&quot;)&#10;        self.logger.info(f&quot;To: {recipient['msisdn']}&quot;)&#10;        self.logger.info(&quot;=&quot; * 60)&#10;&#10;        # Connect to caller device&#10;        if not self.connect_device(caller['ip_port']):&#10;            return False&#10;&#10;        # Make the call&#10;        success = self.make_call(&#10;            caller['ip_port'],&#10;            caller['msisdn'],&#10;            recipient['msisdn']&#10;        )&#10;&#10;        if success and duration:&#10;            self.logger.info(f&quot;Call will remain active for {duration} seconds...&quot;)&#10;            time.sleep(duration)&#10;            self.end_call(caller['ip_port'])&#10;&#10;        return success&#10;&#10;    def interactive_menu(self):&#10;        &quot;&quot;&quot;Display an interactive menu for phone call automation.&quot;&quot;&quot;&#10;        self.logger.info(&quot;=&quot; * 60)&#10;        self.logger.info(&quot;=&quot; * 19 + &quot; PHONE CALL AUTOMATION &quot; + &quot;=&quot; * 18)&#10;        self.logger.info(&quot;=&quot; * 60)&#10;        self.logger.info(f&quot;Phone A: {self.phones['phone A']['msisdn']} @ {self.phones['phone A']['ip_port']}&quot;)&#10;        self.logger.info(f&quot;Phone B: {self.phones['phone B']['msisdn']} @ {self.phones['phone B']['ip_port']}&quot;)&#10;        self.logger.info(&quot;=&quot; * 60)&#10;&#10;        while True:&#10;            print(&quot;\n--- MENU ---&quot;)&#10;            print(&quot;1. Call from Phone A to Phone B&quot;)&#10;            print(&quot;2. Call from Phone B to Phone A&quot;)&#10;            print(&quot;3. End call on Phone A&quot;)&#10;            print(&quot;4. End call on Phone B&quot;)&#10;            print(&quot;5. List connected devices&quot;)&#10;            print(&quot;6. Connect to both phones&quot;)&#10;            print(&quot;7. Disconnect all devices&quot;)&#10;            print(&quot;8. Restart ADB server&quot;)&#10;            print(&quot;0. Exit&quot;)&#10;            print()&#10;&#10;            choice = input(&quot;Enter your choice: &quot;).strip()&#10;&#10;            if choice == &quot;1&quot;:&#10;                duration_str = input(&quot;Enter call duration in seconds (or press Enter to skip auto-end): &quot;).strip()&#10;                duration = int(duration_str) if duration_str else None&#10;                self.make_phone_call('phone A', 'phone B', duration)&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;2&quot;:&#10;                duration_str = input(&quot;Enter call duration in seconds (or press Enter to skip auto-end): &quot;).strip()&#10;                duration = int(duration_str) if duration_str else None&#10;                self.make_phone_call('phone B', 'phone A', duration)&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;3&quot;:&#10;                self.end_call(self.phones['phone A']['ip_port'])&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;4&quot;:&#10;                self.end_call(self.phones['phone B']['ip_port'])&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;5&quot;:&#10;                self.list_devices()&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;6&quot;:&#10;                self.connect_device(self.phones['phone A']['ip_port'])&#10;                self.connect_device(self.phones['phone B']['ip_port'])&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;7&quot;:&#10;                subprocess.run([&quot;adb&quot;, &quot;disconnect&quot;], capture_output=True)&#10;                self.logger.info(&quot;✓ Disconnected all devices&quot;)&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;8&quot;:&#10;                self.restart_adb_server()&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;0&quot;:&#10;                self.logger.info(&quot;Exiting...&quot;)&#10;                break&#10;&#10;            else:&#10;                self.logger.warning(&quot;Invalid choice. Please try again.&quot;)&#10;&#10;    def _wait_for_continue(self) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Wait for user to press Enter to continue or 0 to exit.&#10;&#10;        Returns:&#10;            bool: True to continue to menu, False to exit&#10;        &quot;&quot;&quot;&#10;        print()&#10;        user_input = input(&quot;Press Enter to show the menu or 0 to exit: &quot;).strip()&#10;        if user_input == &quot;0&quot;:&#10;            self.logger.info(&quot;Exiting...&quot;)&#10;            return False&#10;        return True&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function to run the phone call automation.&quot;&quot;&quot;&#10;    # Build logger for phone call automation&#10;    logger = build_logger(&quot;phone_call_automation&quot;)&#10;    automation = PhoneCallAutomation(logger)&#10;&#10;    # Check if ADB is available&#10;    if not automation.check_adb_available():&#10;        logger.error(&quot;\nPlease install ADB and ensure it's in your system PATH.&quot;)&#10;        logger.error(&quot;On Ubuntu/Debian: sudo apt-get install adb&quot;)&#10;        logger.error(&quot;Or download Android Platform Tools from: https://developer.android.com/studio/releases/platform-tools&quot;)&#10;        sys.exit(1)&#10;&#10;    # Run interactive menu&#10;    automation.interactive_menu()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;phone_call_automation.py&#10;Automates phone calls between mobile devices using ADB commands through STF.&#10;&quot;&quot;&quot;&#10;&#10;import subprocess&#10;import time&#10;import sys&#10;from typing import Optional&#10;&#10;from logging_config import build_logger&#10;&#10;&#10;class PhoneCallAutomation:&#10;    &quot;&quot;&quot;Handles automated phone calls between mobile devices via ADB.&quot;&quot;&quot;&#10;&#10;    def __init__(self, logger=None):&#10;        self.phones = {&#10;            &quot;phone A&quot;: {&#10;                &quot;msisdn&quot;: &quot;4915900103141&quot;,&#10;                &quot;ip_port&quot;: &quot;172.29.42.44:7437&quot;&#10;            },&#10;            &quot;phone B&quot;: {&#10;                &quot;msisdn&quot;: &quot;4915781993213&quot;,&#10;                &quot;ip_port&quot;: &quot;172.29.42.44:7445&quot;&#10;            }&#10;        }&#10;        # Initialize logger&#10;        self.logger = logger or build_logger(&quot;phone_call_automation&quot;)&#10;&#10;    def clean_msisdn(self, msisdn: str) -&gt; str:&#10;        &quot;&quot;&quot;Remove spaces from MSISDN.&quot;&quot;&quot;&#10;        return msisdn.replace(&quot; &quot;, &quot;&quot;)&#10;&#10;    def connect_device(self, ip_port: str) -&gt; bool:&#10;        &quot;&quot;&quot;Connect to a device via ADB.&quot;&quot;&quot;&#10;        try:&#10;            self.logger.info(f&quot;Connecting to device at {ip_port}...&quot;)&#10;            result = subprocess.run(&#10;                [&quot;adb&quot;, &quot;connect&quot;, ip_port],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=10&#10;            )&#10;&#10;            if result.returncode == 0:&#10;                self.logger.info(f&quot;✓ Successfully connected to {ip_port}&quot;)&#10;                self.logger.debug(f&quot;Output: {result.stdout.strip()}&quot;)&#10;                return True&#10;            else:&#10;                self.logger.error(f&quot;✗ Failed to connect to {ip_port}&quot;)&#10;                self.logger.error(f&quot;Error: {result.stderr.strip()}&quot;)&#10;                return False&#10;&#10;        except subprocess.TimeoutExpired:&#10;            self.logger.error(f&quot;✗ Connection to {ip_port} timed out&quot;)&#10;            return False&#10;        except FileNotFoundError:&#10;            self.logger.error(&quot;✗ ADB command not found. Please ensure ADB is installed and in PATH.&quot;)&#10;            return False&#10;        except Exception as e:&#10;            self.logger.error(f&quot;✗ Error connecting to {ip_port}: {e}&quot;)&#10;            return False&#10;&#10;    def disconnect_device(self, ip_port: str):&#10;        &quot;&quot;&quot;Disconnect from a device via ADB.&quot;&quot;&quot;&#10;        try:&#10;            self.logger.info(f&quot;Disconnecting from {ip_port}...&quot;)&#10;            subprocess.run(&#10;                [&quot;adb&quot;, &quot;disconnect&quot;, ip_port],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=5&#10;            )&#10;        except Exception as e:&#10;            self.logger.warning(f&quot;Error disconnecting from {ip_port}: {e}&quot;)&#10;&#10;    def make_call(self, caller_ip_port: str, caller_msisdn: str, recipient_msisdn: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Make a phone call from caller device to recipient number.&#10;&#10;        Args:&#10;            caller_ip_port: IP:PORT of the calling device&#10;            caller_msisdn: MSISDN of the caller&#10;            recipient_msisdn: Phone number to call (with country code, no spaces)&#10;&#10;        Returns:&#10;            bool: True if call was initiated successfully&#10;        &quot;&quot;&quot;&#10;        try:&#10;            self.logger.info(f&quot;Initiating call from {caller_msisdn} to {recipient_msisdn}...&quot;)&#10;&#10;            # ADB command to make a call&#10;            # Using 'am start' to launch dialer with phone number&#10;            call_command = f&quot;am start -a android.intent.action.CALL -d tel:{recipient_msisdn}&quot;&#10;&#10;            result = subprocess.run(&#10;                [&quot;adb&quot;, &quot;-s&quot;, caller_ip_port, &quot;shell&quot;, call_command],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=10&#10;            )&#10;&#10;            if result.returncode == 0:&#10;                self.logger.info(f&quot;✓ Call initiated successfully!&quot;)&#10;                self.logger.debug(f&quot;Output: {result.stdout.strip()}&quot;)&#10;                return True&#10;            else:&#10;                self.logger.error(f&quot;✗ Failed to initiate call&quot;)&#10;                self.logger.error(f&quot;Error: {result.stderr.strip()}&quot;)&#10;                return False&#10;&#10;        except subprocess.TimeoutExpired:&#10;            self.logger.error(f&quot;✗ Call command timed out&quot;)&#10;            return False&#10;        except Exception as e:&#10;            self.logger.error(f&quot;✗ Error making call: {e}&quot;)&#10;            return False&#10;&#10;    def end_call(self, device_ip_port: str) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        End the current call on a device.&#10;&#10;        Args:&#10;            device_ip_port: IP:PORT of the device&#10;&#10;        Returns:&#10;            bool: True if call was ended successfully&#10;        &quot;&quot;&quot;&#10;        try:&#10;            self.logger.info(f&quot;Ending call on {device_ip_port}...&quot;)&#10;&#10;            # Send keyevent to end call (KEYCODE_ENDCALL = 6)&#10;            result = subprocess.run(&#10;                [&quot;adb&quot;, &quot;-s&quot;, device_ip_port, &quot;shell&quot;, &quot;input&quot;, &quot;keyevent&quot;, &quot;6&quot;],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=5&#10;            )&#10;&#10;            if result.returncode == 0:&#10;                self.logger.info(f&quot;✓ Call ended successfully&quot;)&#10;                return True&#10;            else:&#10;                self.logger.error(f&quot;✗ Failed to end call&quot;)&#10;                self.logger.error(f&quot;Error: {result.stderr.strip()}&quot;)&#10;                return False&#10;&#10;        except Exception as e:&#10;            self.logger.error(f&quot;✗ Error ending call: {e}&quot;)&#10;            return False&#10;&#10;    def check_adb_available(self) -&gt; bool:&#10;        &quot;&quot;&quot;Check if ADB is available in the system.&quot;&quot;&quot;&#10;        try:&#10;            result = subprocess.run(&#10;                [&quot;adb&quot;, &quot;version&quot;],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=5&#10;            )&#10;            if result.returncode == 0:&#10;                version = result.stdout.strip().split()[4] if len(result.stdout.strip().split()) &gt; 4 else &quot;unknown&quot;&#10;                self.logger.info(f&quot;✓ ADB is available (Version: {version})&quot;)&#10;                return True&#10;            return False&#10;        except FileNotFoundError:&#10;            self.logger.error(&quot;✗ ADB is not installed or not in PATH&quot;)&#10;            return False&#10;        except Exception as e:&#10;            self.logger.error(f&quot;✗ Error checking ADB: {e}&quot;)&#10;            return False&#10;&#10;    def restart_adb_server(self) -&gt; bool:&#10;        &quot;&quot;&quot;Restart the ADB server by killing and starting it again.&quot;&quot;&quot;&#10;        try:&#10;            self.logger.info(&quot;Killing ADB server...&quot;)&#10;            result_kill = subprocess.run(&#10;                [&quot;adb&quot;, &quot;kill-server&quot;],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=10&#10;            )&#10;&#10;            if result_kill.returncode == 0:&#10;                self.logger.info(&quot;✓ ADB server killed successfully&quot;)&#10;            else:&#10;                self.logger.warning(f&quot;Warning: {result_kill.stderr.strip()}&quot;)&#10;&#10;            time.sleep(1)&#10;&#10;            self.logger.info(&quot;Starting ADB server...&quot;)&#10;            result_start = subprocess.run(&#10;                [&quot;adb&quot;, &quot;start-server&quot;],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=10&#10;            )&#10;&#10;            if result_start.returncode == 0:&#10;                self.logger.info(&quot;✓ ADB server started successfully&quot;)&#10;                self.logger.info(&quot;Note: You may need to authorize the connection on your device(s)&quot;)&#10;                return True&#10;            else:&#10;                self.logger.error(f&quot;✗ Failed to start ADB server: {result_start.stderr.strip()}&quot;)&#10;                return False&#10;&#10;        except subprocess.TimeoutExpired:&#10;            self.logger.error(&quot;✗ ADB server restart timed out&quot;)&#10;            return False&#10;        except Exception as e:&#10;            self.logger.error(f&quot;✗ Error restarting ADB server: {e}&quot;)&#10;            return False&#10;&#10;    def list_devices(self):&#10;        &quot;&quot;&quot;List all connected ADB devices.&quot;&quot;&quot;&#10;        try:&#10;            result = subprocess.run(&#10;                [&quot;adb&quot;, &quot;devices&quot;],&#10;                capture_output=True,&#10;                text=True,&#10;                timeout=5&#10;            )&#10;            self.logger.info(&quot;=== Connected ADB Devices ===&quot;)&#10;            for line in result.stdout.strip().split('\n'):&#10;                self.logger.info(line)&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Error listing devices: {e}&quot;)&#10;&#10;    def make_phone_call(self, from_phone: str, to_phone: str, duration: Optional[int] = None):&#10;        &quot;&quot;&quot;&#10;        Make a phone call from one device to another.&#10;&#10;        Args:&#10;            from_phone: Caller phone ID ('phone1' or 'phone2')&#10;            to_phone: Recipient phone ID ('phone1' or 'phone2')&#10;            duration: Optional duration in seconds to keep the call active before ending&#10;&#10;        Returns:&#10;            bool: True if call was initiated successfully&#10;        &quot;&quot;&quot;&#10;        if from_phone not in self.phones or to_phone not in self.phones:&#10;            self.logger.error(f&quot;✗ Invalid phone ID. Use 'phone A' or 'phone B'&quot;)&#10;            return False&#10;&#10;        caller = self.phones[from_phone]&#10;        recipient = self.phones[to_phone]&#10;&#10;        self.logger.info(&quot;=&quot; * 60)&#10;        self.logger.info(f&quot;CALLING: {from_phone.upper()} → {to_phone.upper()}&quot;)&#10;        self.logger.info(f&quot;From: {caller['msisdn']} ({caller['ip_port']})&quot;)&#10;        self.logger.info(f&quot;To: {recipient['msisdn']}&quot;)&#10;        self.logger.info(&quot;=&quot; * 60)&#10;&#10;        # Connect to caller device&#10;        if not self.connect_device(caller['ip_port']):&#10;            return False&#10;&#10;        # Make the call&#10;        success = self.make_call(&#10;            caller['ip_port'],&#10;            caller['msisdn'],&#10;            recipient['msisdn']&#10;        )&#10;&#10;        if success and duration:&#10;            self.logger.info(f&quot;Call will remain active for {duration} seconds...&quot;)&#10;            time.sleep(duration)&#10;            self.end_call(caller['ip_port'])&#10;&#10;        return success&#10;&#10;    def interactive_menu(self):&#10;        &quot;&quot;&quot;Display an interactive menu for phone call automation.&quot;&quot;&quot;&#10;        self.logger.info(&quot;=&quot; * 60)&#10;        self.logger.info(&quot;=&quot; * 19 + &quot; PHONE CALL AUTOMATION &quot; + &quot;=&quot; * 18)&#10;        self.logger.info(&quot;=&quot; * 60)&#10;        self.logger.info(f&quot;Phone A: {self.phones['phone A']['msisdn']} @ {self.phones['phone A']['ip_port']}&quot;)&#10;        self.logger.info(f&quot;Phone B: {self.phones['phone B']['msisdn']} @ {self.phones['phone B']['ip_port']}&quot;)&#10;        self.logger.info(&quot;=&quot; * 60)&#10;&#10;        while True:&#10;            print(&quot;\n--- MENU ---&quot;)&#10;            print(&quot;1. Call from Phone A to Phone B&quot;)&#10;            print(&quot;2. Call from Phone B to Phone A&quot;)&#10;            print(&quot;3. End call on Phone A&quot;)&#10;            print(&quot;4. End call on Phone B&quot;)&#10;            print(&quot;5. List connected devices&quot;)&#10;            print(&quot;6. Connect to both phones&quot;)&#10;            print(&quot;7. Disconnect all devices&quot;)&#10;            print(&quot;8. Restart ADB server&quot;)&#10;            print(&quot;0. Exit&quot;)&#10;            print()&#10;&#10;            choice = input(&quot;Enter your choice: &quot;).strip()&#10;&#10;            if choice == &quot;1&quot;:&#10;                duration_str = input(&quot;Enter call duration in seconds (or press Enter to skip auto-end): &quot;).strip()&#10;                duration = int(duration_str) if duration_str else None&#10;                self.make_phone_call('phone A', 'phone B', duration)&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;2&quot;:&#10;                duration_str = input(&quot;Enter call duration in seconds (or press Enter to skip auto-end): &quot;).strip()&#10;                duration = int(duration_str) if duration_str else None&#10;                self.make_phone_call('phone B', 'phone A', duration)&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;3&quot;:&#10;                self.end_call(self.phones['phone A']['ip_port'])&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;4&quot;:&#10;                self.end_call(self.phones['phone B']['ip_port'])&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;5&quot;:&#10;                self.list_devices()&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;6&quot;:&#10;                self.connect_device(self.phones['phone A']['ip_port'])&#10;                self.connect_device(self.phones['phone B']['ip_port'])&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;7&quot;:&#10;                subprocess.run([&quot;adb&quot;, &quot;disconnect&quot;], capture_output=True)&#10;                self.logger.info(&quot;✓ Disconnected all devices&quot;)&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;8&quot;:&#10;                self.restart_adb_server()&#10;                if not self._wait_for_continue():&#10;                    break&#10;&#10;            elif choice == &quot;0&quot;:&#10;                self.logger.info(&quot;Exiting...&quot;)&#10;                break&#10;&#10;            else:&#10;                self.logger.warning(&quot;Invalid choice. Please try again.&quot;)&#10;&#10;    def _wait_for_continue(self) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Wait for user to press Enter to continue or 0 to exit.&#10;&#10;        Returns:&#10;            bool: True to continue to menu, False to exit&#10;        &quot;&quot;&quot;&#10;        print()&#10;        user_input = input(&quot;Press Enter to show the menu or 0 to exit: &quot;).strip()&#10;        if user_input == &quot;0&quot;:&#10;            self.logger.info(&quot;Exiting...&quot;)&#10;            return False&#10;        return True&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function to run the phone call automation.&quot;&quot;&quot;&#10;    # Build logger for phone call automation&#10;    logger = build_logger(&quot;phone_call_automation&quot;)&#10;    automation = PhoneCallAutomation(logger)&#10;&#10;    # Check if ADB is available&#10;    if not automation.check_adb_available():&#10;        logger.error(&quot;\nPlease install ADB and ensure it's in your system PATH.&quot;)&#10;        logger.error(&quot;On Ubuntu/Debian: sudo apt-get install adb&quot;)&#10;        logger.error(&quot;Or download Android Platform Tools from: https://developer.android.com/studio/releases/platform-tools&quot;)&#10;        sys.exit(1)&#10;&#10;    # Run interactive menu&#10;    automation.interactive_menu()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>